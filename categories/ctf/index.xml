<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>CTF on Psyduck的秘密小窝</title>
        <link>https://psyduck-2005.github.io/categories/ctf/</link>
        <description>Recent content in CTF on Psyduck的秘密小窝</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>psyduck2005</copyright>
        <lastBuildDate>Mon, 22 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://psyduck-2005.github.io/categories/ctf/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>canary理解</title>
        <link>https://psyduck-2005.github.io/p/canary/</link>
        <pubDate>Mon, 22 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://psyduck-2005.github.io/p/canary/</guid>
        <description>&lt;img src="https://psyduck-2005.github.io/p/canary/emperor.jpg" alt="Featured image of post canary理解" /&gt;&lt;h2 id=&#34;canary简单介绍&#34;&gt;canary简单介绍
&lt;/h2&gt;&lt;h3 id=&#34;canary原理&#34;&gt;canary原理
&lt;/h3&gt;&lt;p&gt;canary是一种用来防护栈溢出的保护机制。其原理是在一个函数的入口处，先从fs/gs寄存器中取出一个4字节(eax)或者8字节,(其长度多半一个字长，rax)的值存到栈上，当函数结束时会检查这个栈上的值是否和存进去的值一致。canary在64位下保护包括rbp rip在内的数据,将其安排到前一个栈帧。
它的生命周期可以分为三个阶段:生成 -&amp;gt; 存储 -&amp;gt; 使用（校验）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://psyduck-2005.github.io/p/canary/1.jpg&#34;
	width=&#34;444&#34;
	height=&#34;465&#34;
	srcset=&#34;https://psyduck-2005.github.io/p/canary/1_hu_3423ef6e4ff1d1bd.jpg 480w, https://psyduck-2005.github.io/p/canary/1_hu_b62398cb710fd66a.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;正常的canary&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;229px&#34;
	
&gt; &lt;img src=&#34;https://psyduck-2005.github.io/p/canary/2.jpg&#34;
	width=&#34;504&#34;
	height=&#34;464&#34;
	srcset=&#34;https://psyduck-2005.github.io/p/canary/2_hu_c829143cfe28bdc4.jpg 480w, https://psyduck-2005.github.io/p/canary/2_hu_f46c491734dff3f0.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;被覆盖的canary&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;108&#34;
		data-flex-basis=&#34;260px&#34;
	
&gt; &lt;img src=&#34;https://psyduck-2005.github.io/p/canary/3.jpg&#34;
	width=&#34;548&#34;
	height=&#34;339&#34;
	srcset=&#34;https://psyduck-2005.github.io/p/canary/3_hu_2e39f1a2353c7c4f.jpg 480w, https://psyduck-2005.github.io/p/canary/3_hu_d7a92d6c61274bc4.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;跳转报错函数&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;161&#34;
		data-flex-basis=&#34;387px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;canary的生成：源头是安全随机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Linux 系统上，这个值通常来自 /dev/urandom 这个内核提供的密码学安全伪随机数生成器（CSPRNG）。生成的 Canary 值通常是一个 64 位或 32 位的整数（取决于平台），并且其字节值通常会包含 0x00（空字节）。因为许多导致栈溢出的攻击向量是字符串操作函数（如 strcpy, gets）。这些函数在遇到空字节 0x00 时会停止复制。如果 Canary 中包含空字节，攻击者试图用字符串操作覆盖 Canary 时就会在中途停止，从而无法完整地覆盖和篡改它，导致攻击失败。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;存储：线程本地存储 (TLS)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生成的 Canary 值存储在哪里？它存储在 线程本地存储 (Thread-Local Storage, TLS) 中。并且每个线程拥有一个。一个程序可能有多个线程，每个线程都有自己的调用栈。如果所有线程共享一个全局的 Canary 值，那么一个线程泄漏了这个值，所有线程的保护就都失效了。为每个线程使用独立的 Canary 值可以隔离风险。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://psyduck-2005.github.io/p/canary/4.jpg&#34;
	width=&#34;839&#34;
	height=&#34;853&#34;
	srcset=&#34;https://psyduck-2005.github.io/p/canary/4_hu_34d8fe5eb33477f9.jpg 480w, https://psyduck-2005.github.io/p/canary/4_hu_e42b0ee96479d03b.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多线程的canary工作,每个线程有自己独立的主金丝雀值（M1和M2不同）&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;98&#34;
		data-flex-basis=&#34;236px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;访问：通过特殊寄存器(fs)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 x86-64 架构中，有一个特殊的段寄存器 %fs（或 %gs）用于指向 TLS。Canary 值通常位于 TLS 中的一个固定偏移处。编译器生成的代码会通过类似 %fs:0x28 这样的地址来访问当前线程的 Canary 值。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;使用与校验：函数序言和尾声&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在，我们看一个函数是如何使用这个值的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数序言 (Prologue)：
当一个被保护的函数开始时，编译器插入的代码会做两件事：从 TLS（如 %fs:0x28）中取出当前线程的 Canary 值。将这个 Canary 值压入到该函数栈帧上的一个特定位置（通常就在保存的基指针和返回地址之前）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;汇编代码看起来像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;rax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;qword&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;%fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0x28&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;; 从TLS中取出Canary值到rax寄存器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;qword&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;rsp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;rax&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;; 将Canary值压入栈上的保护位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;函数尾声 (Epilogue)：
在函数返回（ret指令）之前，编译器插入的代码会：从栈上之前保存的位置读出 Canary 值。将其与 TLS 中存储的原始 Master Canary 值进行比较。如果两者相等，程序正常返回。如果不相等，说明栈上的 Canary 在函数执行过程中被溢出数据覆盖了，此时会立即跳转到 __stack_chk_fail 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;汇编代码看起来像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;rdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;qword&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;rsp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;; 从栈上取出保存的Canary值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sub&lt;/span&gt;    &lt;span class=&#34;no&#34;&gt;rdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;qword&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;%fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0x28&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;; 与TLS中的原始值进行比较
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;je&lt;/span&gt;     &lt;span class=&#34;no&#34;&gt;.return_normal&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;; 如果相等（结果为0），跳转到返回指令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt;   &lt;span class=&#34;no&#34;&gt;__stack_chk_fail&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;; 否则，调用失败处理函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;.return_normal:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;leave&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;ret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;__stack_chk_fail 函数会打印出著名的 &amp;ldquo;*** stack smashing detected ***: &lt;program name&gt; terminated&amp;rdquo; 错误信息，然后调用 abort() 终止程序，阻止攻击者代码执行。&lt;/p&gt;
&lt;h3 id=&#34;canary初始化源码&#34;&gt;canary初始化源码
&lt;/h3&gt;&lt;p&gt;security_init.c函数部分源码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;security_init&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// _dl_random的值在进入这个函数之前已由内核写入（通常在程序启动时）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// Glibc直接使用_dl_random的值，而不是自己生成随机数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 将_dl_random的最后一个字节设置为0x0（通过_dl_setup_stack_chk_guard函数）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uintptr_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack_chk_guard&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_dl_setup_stack_chk_guard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_dl_random&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 设置Canary的值到当前线程的TLS（线程本地存储）中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;THREAD_SET_STACK_GUARD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack_chk_guard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 将_dl_random置为NULL，防止后续使用（可能出于安全原因）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;_dl_random&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 后续可能还有其他安全初始化操作（注释提到&amp;#34;下面就是对canary的一些准备&amp;#34;）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关键宏定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define THREAD_SET_STACK_GUARD(value) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;    THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  _dl_random：这是一个由内核提供的随机值（通常通过AT_RANDOM AUXV条目传递），作为栈保护canary的种子。

  _dl_setup_stack_chk_guard：这个函数处理canary的生成：

  使用`_dl_random`作为输入,将最后一个字节设置为0（这是为了阻止C字符串函数覆盖canary值，因为许多字符串漏洞依赖NULL终止符）

  THREAD_SET_STACK_GUARD：这个宏将生成的canary值存储到当前线程的TLS中：

  THREAD_SELF:获取当前线程的TLS指针

  header.stack_guard是TLS中存储栈保护值的字段位置

  使用THREAD_SETMEM将值写入指定位置

  _dl_random = NULL：清除随机值源，可能是为了：减少攻击面,防止意外重复使用
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完整的数据流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  内核 → 通过AT_RANDOM AUXV条目提供 _dl_random

  _dl_setup_stack_chk_guard → 处理随机值，设置最后字节为0

  THREAD_SET_STACK_GUARD → 将canary存储到当前线程TLS

  编译器 → 在函数 prologue/epilogue 中插入canary检查代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;uintptr_t&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;数据类型解释&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;canary报错源码&#34;&gt;canary报错源码
&lt;/h3&gt;&lt;p&gt;stack_chk_fail.c源码解析&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;libc_message&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;** %s ***: %s terminated&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__libc_argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;lt;unknown&amp;gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;libc_message()&lt;/code&gt;: GNU C库内部的函数，用于输出系统消息,2: 第一个参数，通常表示标准错误输出（stderr）&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;格式化字符串&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;** %s ***: %s terminatedn&amp;quot;&lt;/code&gt;: 格式化字符串模板,第一个 %s: 将被 msg 替换,第二个 %s: 将被程序名替换&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;msg: 具体的错误消息字符串
&lt;code&gt;__libc_argv[0]?: &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__libc_argv[0]&lt;/code&gt;: 程序的名称（argv[0]）
&lt;code&gt;?: &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;:&lt;/code&gt; 三元条件运算符，如果程序名为空则使用&lt;code&gt;&amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;实际输出示例&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 msg = &amp;ldquo;stack smashing detected&amp;rdquo;，程序名为 ./test，输出将是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;** stack smashing detected ***: ./test terminated
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;canary开启模式&#34;&gt;canary开启模式
&lt;/h2&gt;&lt;p&gt;canary主要分为三种（关闭/开启/全开启）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-fstack-protector&lt;/code&gt; 和 &lt;code&gt;-fstack-protector-all&lt;/code&gt; 都是用于防范栈溢出攻击的保护机制，但它们的保护范围和性能影响有显著区别。&lt;/p&gt;
&lt;h3 id=&#34;-fstack-protector默认的栈保护&#34;&gt;&lt;code&gt;-fstack-protector&lt;/code&gt;（默认的栈保护）
&lt;/h3&gt;&lt;p&gt;这是选择性保护模式。编译器会进行启发式判断，只对包含敏感操作（如字符数组操作）或容易遭受攻击的函数插入保护代码。&lt;/p&gt;
&lt;p&gt;保护对象：满足以下条件的函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用了 alloca() 函数在栈上动态分配内存的。&lt;/li&gt;
&lt;li&gt;定义了大于 8 字节的&lt;strong&gt;字符&lt;/strong&gt;数组（char） 或缓冲区（通常是可能发生溢出的源头）的局部变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;性能：性能开销较小。因为只对一部分“危险”函数进行保护，生成的代码量更小，运行时检查也更少。
安全性：保护范围有限。它可能会错过一些不那么明显但依然存在漏洞的函数。例如，一个使用 int 数组但可能溢出的函数就不会被保护。
用途：这是 GCC 的默认行为（如果启用了栈保护）。在安全性和性能之间提供了一个很好的平衡，适用于大多数情况。&lt;/p&gt;
&lt;p&gt;示例：会被 &lt;code&gt;-fstack-protector&lt;/code&gt; 保护的函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;vulnerable_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 大的字符数组 -&amp;gt; 会被保护
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;gets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 危险操作！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;-fstack-protector-all强栈保护&#34;&gt;&lt;code&gt;-fstack-protector-all&lt;/code&gt;（强栈保护）
&lt;/h3&gt;&lt;p&gt;这是全面保护模式。编译器会为所有函数插入保护代码，无论其是否看起来存在风险。
保护对象：每一个函数，无论其内部结构如何。&lt;/p&gt;
&lt;p&gt;性能：性能开销较大。每个函数在入口和出口都有额外的代码来设置和检查金丝雀值。这会导致生成的二进制文件更大，运行速度稍慢。
安全性：保护范围非常全面。消除了由于编译器启发式判断失误而漏掉漏洞的可能性，提供了更深度的防御。
用途：用于对安全性要求极高的环境，愿意为此牺牲一定的性能。例如，处理不受信任输入的特权程序（sudo, sshd 等）、安全关键型的系统。&lt;/p&gt;
&lt;p&gt;示例：会被&lt;code&gt;-fstack-protector-all&lt;/code&gt;保护的函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;innocent_looking_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 整型数组，通常不会被启发式规则认为是危险的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 糟糕！这里有一个“差一错误”（Off-by-one）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 当 i=10 时，会发生栈溢出，覆盖返回地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 使用 `-fstack-protector` 可能不会保护此函数，但 `-fstack-protector-all` 会。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;其他保护类型&#34;&gt;其他保护类型
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;-fstack-protector-strong&lt;/code&gt;：这是一个介于 &lt;code&gt;-fstack-protector&lt;/code&gt; 和 &lt;code&gt;-fstack-protector-all&lt;/code&gt; 之间的选项（GCC 4.9 引入）。它扩展了启发式规则，比 &lt;code&gt;-fstack-protector&lt;/code&gt; 保护更多的函数（例如，包含任何类型的数组、有局部变量地址被使用的函数），在不过度增加开销的情况下提供了更好的保护。在许多现代Linux发行版中，这已成为默认的编译选项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-fno-stack-protector&lt;/code&gt;：完全禁用栈保护。&lt;/p&gt;
&lt;h2 id=&#34;canary绕过&#34;&gt;canary绕过
&lt;/h2&gt;&lt;h3 id=&#34;canary检测&#34;&gt;canary检测
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_stack_canary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 从第一个参数开始探测&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;binary&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 存储接收到的数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 最多探测100个参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;$p&amp;#34;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 格式化字符串payload：读取第i个参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;io&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 获取IO连接（可能是到目标程序的连接）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sendline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 发送payload&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;recv&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;recvline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 接收响应&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;binary&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;recv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 取响应内容的最后几个字节（可能有误）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;binary&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;00&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 检查特定模式（这里逻辑可能有问题）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;--找到一个可疑的偏移：&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;recv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;--&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;正在进行二次测试&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 重新建立连接进行验证&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;payload_2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;$p&amp;#34;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 同样的payload&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sendline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;payload_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;recv2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;recvline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;recv2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;recv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:]:&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 如果两次结果不同&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;...他是canary的几率很大:&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;recv2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;failure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;--哦，他不是canary--&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 测试下一个参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这是一个canary自动检测方案（不需要手打printf，来自B站某up）&lt;/p&gt;
&lt;h3 id=&#34;canary绕过方法&#34;&gt;canary绕过方法
&lt;/h3&gt;&lt;h4 id=&#34;泄露&#34;&gt;泄露
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;格式化字符串泄露&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位Canary：首先需要确定Canary在栈上的偏移位置。在格式化字符串漏洞中，我们可以使用类似 %p %p %p %p &amp;hellip; 或 %n$p（n是位置参数）的方式来“窥探”栈上的内容。&lt;/li&gt;
&lt;li&gt;识别Canary：Canary的值通常以字节 0x00 结尾（这是为了阻止使用字符串操作函数如 strcpy 来泄露它，因为 strcpy 遇到 0x00 会终止）。所以当我们从栈上泄露出一串地址，其中一个值最后两个字节是 00（例如 0x1b2d3c4d5a6b00），它极有可能就是Canary。&lt;/li&gt;
&lt;li&gt;构造Payload：在后续的溢出中，在覆盖到Canary的位置时，精确地用我们泄露出来的这个值填充，这样函数尾声的校验就会通过，程序不会崩溃，攻击得以继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爆破（fork）&lt;/p&gt;
&lt;p&gt;原理：爆破（Brute-Force）Canary（适用于fork服务）这种方法常用于网络服务，这些服务使用 fork() 模式来处理客户端连接（例如，一个主进程监听，每来一个连接就fork一个子进程来处理）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程内存镜像复制（Fork）：fork() 创建的子进程会完整地复制父进程的内存空间。这意味着每个连接对应的子进程，其Canary值是完全相同的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逐字节爆破：Canary通常是一个4字节（32位）或8字节（64位）的值，但其最后一个字节固定为 0x00。所以我们只需要爆破前面的3或7个字节。
攻击者可以多次连接服务，每次尝试爆破Canary的一个字节。从最低位字节（LSB）开始（注意小端序，内存中第一个字节是最低位）。
例如，对于一个64位Canary 0x00 0xab 0xcd 0xef 0x12 0x34 0x56 0x78，爆破顺序是从 0x78 开始，然后是 0x56，依此类推，直到 0xab（0x00 不用爆，直接填）。利用崩溃反馈：攻击者发送一个精心构造的payload：[填充缓冲区的垃圾数据] + [已猜解的部分Canary] + [尝试爆破的下一个字节]。如果这个字节猜对了，Canary校验通过，程序不会崩溃，可能会因为后续的返回地址错误而表现出其他行为（比如连接意外断开或无响应）。如果猜错了，__stack_chk_fail 会被触发，子进程立刻崩溃。攻击者通过观察连接是否“立即断开”（崩溃）来判断字节是否猜对。重复过程：从一个字节开始，逐步猜出整个Canary。因为每次猜一个字节（256种可能性），所以最多只需要 7 * 256 = 1792 次尝试，这在计算上是完全可行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于每次连接fork出的新进程，其Canary都和上一次一样。上次猜对的字节，这次依然有效，所以可以基于已知字节继续猜下一个。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连带输出&lt;/p&gt;
&lt;p&gt;这种方法利用了格式化字符串和程序逻辑的结合。&lt;/p&gt;
&lt;p&gt;原理漏洞组合：程序存在两个漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个栈溢出漏洞（用于覆盖Canary和返回地址）。&lt;/li&gt;
&lt;li&gt;一个格式化字符串漏洞（用于泄露信息）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;触发流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;攻击者首先构造一个不完全的溢出Payload。这个Payload会覆盖Canary之后的一部分栈空间，但故意不覆盖Canary本身（或者用可能正确的值覆盖，期望它能通过），而是去覆盖一个即将被格式化字符串函数使用的参数（比如格式化字符串的指针本身，或者一个指向指针的指针）。&lt;/li&gt;
&lt;li&gt;程序执行流继续，并没有因为栈溢出而崩溃（因为Canary没被破坏或碰巧猜对了）。&lt;/li&gt;
&lt;li&gt;程序随后执行到存在格式化字符串漏洞的代码（例如 printf(user_input)）。但此时，栈上的状态已经被之前的溢出Payload修改了。&lt;/li&gt;
&lt;li&gt;被修改的栈空间，恰好控制了格式化字符串函数的一个或多个参数。攻击者可以精心设计，让这个格式化字符串（例如 %n$p）去读取并输出栈上任意位置的值，其中就包括真正的Canary。&lt;/li&gt;
&lt;li&gt;程序将这个Canary值打印（输出） 给攻击者。&lt;/li&gt;
&lt;li&gt;完成攻击：攻击者拿到Canary后，就可以在第二次交互中，构造一个完整的、包含正确Canary的ROP链Payload，最终实现利用。
这种方法的核心是“用一次不完美的溢出来为格式化字符串漏洞配置环境，从而泄露关键信息，为第二次的攻击做准备”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;stack-smashing-223&#34;&gt;Stack smashing (2.23)
&lt;/h4&gt;&lt;p&gt;在这个版本下缺少某些保护（如full relro）但是拥有aslr，nx，canary等常规保护&lt;/p&gt;
&lt;h4 id=&#34;劫持_stack_chk_fail&#34;&gt;劫持_stack_chk_fail
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;函数行为
检测到栈溢出：如果攻击者通过栈溢出（例如，缓冲区溢出）覆盖了函数的返回地址，那么很可能会同时覆盖这个金丝雀值。函数在返回前检查发现金丝雀值不匹配，就会调用 __stack_chk_fail 函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;行为：__stack_chk_fail 的默认实现是打印一条错误信息（如 &amp;ldquo;** stack smashing detected **&amp;quot;）并立即终止程序（通常通过 abort()）。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;劫持 __stack_chk_fail目的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;获取程序控制流：在栈溢出攻击中，攻击者可能无法精确地控制金丝雀值。如果触发了栈保护，程序会崩溃，攻击失败。通过劫持 __stack_chk_fail，攻击者可以将崩溃转化为机会：不让程序简单地退出，而是让它跳转到攻击者控制的代码（Shellcode）。&lt;/p&gt;
&lt;p&gt;信息泄露：在某些高级攻击中（如通过覆盖局部变量实现的部分写），可能故意触发 __stack_chk_fail 来泄露内存信息或其他数据。&lt;/p&gt;
&lt;p&gt;绕过保护：这是最直接的动机。通过控制 __stack_chk_fail 的行为，攻击者实质上禁用或绕过了栈保护机制，使得传统的栈溢出攻击得以继续。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;劫持 __stack_chk_fail方法
覆盖程序运行时使用的 __stack_chk_fail 函数的地址。主要有以下几种方法：
修改 GOT 表（全局偏移表） - 最常见的方法
这通常是 基于二进制漏洞利用 的首选方法，因为它不需要源代码。
原理：在 Linux 等使用 ELF 格式的系统中，共享库函数（如 __stack_chk_fail，它位于 libc 中）的地址存储在名为 GOT 的数据段中。程序在调用 __stack_chk_fail 时，实际上是通过 GOT 表进行间接跳转。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 objdump -R ./binary 或 readelf -r ./binary 命令查找 __stack_chk_fail 在 GOT 中的地址。你会看到一条记录，显示 __&lt;a class=&#34;link&#34; href=&#34;mailto:stack_chk_fail@got.plt&#34; &gt;stack_chk_fail@got.plt&lt;/a&gt; 的地址（例如 0x804a00c）。&lt;/p&gt;
&lt;p&gt;找到你的 Shellcode 在内存中的地址（例如 0xffffd100）。&lt;/p&gt;
&lt;p&gt;利用漏洞：通过栈溢出或其他内存破坏漏洞（如格式化字符串漏洞），将 GOT 表中 __stack_chk_fail 的条目覆盖为你想要的地址（例如你的 Shellcode 地址）。&lt;/p&gt;
&lt;p&gt;触发检查：故意造成一个栈溢出，触发栈保护检查。程序会照常去调用 __stack_chk_fail，但由于 GOT 表被修改，它实际上会跳转到你的 Shellcode 地址，从而执行你的代码。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;防御措施
现代系统针对这种劫持技术也有相应的防御措施：
RELRO（Relocations Read-Only）是一种用于增强 Linux 下 ELF 二进制文件安全性的安全加固技术。它的主要目标是保护 ELF 二进制文件中的某些关键数据结构（主要是动态链接相关的部分）在运行时不被恶意修改，从而防止一系列利用漏洞（如全局偏移表GOT覆盖攻击）的攻击手段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一篇论文
&lt;a class=&#34;link&#34; href=&#34;https://seclists.org/oss-sec/2018/q1/195&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 上 ASLR 的新旁路和保护技术&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;这是无符号整数类型，具有以下关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型定义：在 &amp;lt;stdint.h&amp;gt; 头文件中定义&lt;/li&gt;
&lt;li&gt;用途：能够安全地存储指针值的无符号整数类型&lt;/li&gt;
&lt;li&gt;保证：任何有效的（void*）指针都可以转换为uintptr_t，然后再转换回（void*）而不会丢失信息&lt;/li&gt;
&lt;li&gt;平台兼容性：指针大小随架构变化（32位 vs 64位），uintptr_t &lt;strong&gt;会自动匹配当前平台的指针大小&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整数运算：canary值需要进行位操作（如设置最后字节为0），使用整数类型便于进行位运算，但需要保证与指针相同的位宽&lt;/li&gt;
&lt;/ul&gt;
&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>ptmalloc2理解</title>
        <link>https://psyduck-2005.github.io/p/ptmalloc2/</link>
        <pubDate>Sun, 21 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://psyduck-2005.github.io/p/ptmalloc2/</guid>
        <description>&lt;img src="https://psyduck-2005.github.io/helena-hertz-wWZzXlDpMog-unsplash.jpg" alt="Featured image of post ptmalloc2理解" /&gt;&lt;h3 id=&#34;unsorted-bins&#34;&gt;Unsorted bins
&lt;/h3&gt;&lt;h3 id=&#34;fastbins&#34;&gt;Fastbins
&lt;/h3&gt;&lt;p&gt;链表头部为&amp;rsquo;fastbinY[i]&amp;lsquo;不是一般的&amp;rsquo;bin[i]&amp;rsquo;，共有7个从0x20到0x80每个中包含大小相同的chunk，由单项链表连接，单项链表只有fd指针
fastbin的fd指针会一直保留，不会作废，在进行内容读取时候可以进行覆写，如double free漏洞，uaf漏洞&lt;/p&gt;
&lt;h3 id=&#34;small-bins&#34;&gt;Small bins
&lt;/h3&gt;&lt;h3 id=&#34;large-bins&#34;&gt;Large bins
&lt;/h3&gt;</description>
        </item>
        
    </channel>
</rss>
